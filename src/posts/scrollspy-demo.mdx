---
title: "ScrollSpy 기능 테스트"
date: "2025-06-03"
description: "스크롤스파이와 목차 기능을 테스트하는 긴 글입니다."
image: "/images/hello-thumbnail.jpeg  "
tags: ["frontend"]
featured: true
---

## 1. 소개

이 문서는 블로그에서 스크롤스파이 기능이 잘 작동하는지 확인하기 위해 작성되었습니다.  
많은 heading을 포함하며, 목차와의 연결이 잘 되는지 체크합니다.

<br />
<br />
<br />
<br />

## 2. 스크롤스파이란?

스크롤스파이는 사용자가 페이지를 스크롤할 때,  
현재 보고 있는 heading 섹션에 따라 UI(예: 목차)가 동적으로 변하는 기능입니다.

<br />
<br />
<br />
<br />

### 2.1 Intersection Observer

Intersection Observer는 특정 요소가 뷰포트에 들어왔는지를 감지할 수 있는 API입니다.  
React에서는 이를 기반으로 scrollspy를 구현할 수 있습니다.

<br />
<br />
<br />
<br />

### 2.2 heading에 ID 자동 부여

`rehype-slug`를 사용하면 모든 heading(`##`, `###`)에 자동으로 id가 붙습니다.  
이를 기반으로 anchor 링크를 연결할 수 있습니다.

<br />
<br />
<br />
<br />

## 3. React에서의 구현

스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.
스크롤스파이는 직접 구현하거나 라이브러리를 사용할 수 있습니다.

<br />
<br />
<br />
<br />

### 3.1 커스텀 훅 예시

```tsx
function useActiveSection(ids: string[]) {
  const [activeId, setActiveId] = useState(null);

  useEffect(() => {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          setActiveId(entry.target.id);
        }
      });
    });

    ids.forEach((id) => {
      const element = document.getElementById(id);
      if (element) observer.observe(element);
    });

    return () => observer.disconnect();
  }, [ids]);

  return activeId;
}
```
